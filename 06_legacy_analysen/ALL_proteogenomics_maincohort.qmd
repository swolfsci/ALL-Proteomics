---
title: "ALL_proteogenomics_maincohort"
author: "Sebastian Wolf"
format: html
---

# Introduction

# Analysis

```{r}
library(tidyverse)

theme_set(cowplot::theme_minimal_grid() + cowplot::panel_border() + theme(legend.position = "bottom"))
```

## Data prep

### Sample metadata

```{r}
sample_metadata_facs <- readxl::read_excel(("Data/Proteomics/20230720_cremer_all_maincohort/B-ALL_Kohorte082013_MS_analyse.xlsx"), skip = 2, sheet = 1)

sample_metadata_ms <- readxl::read_excel(("Data/Proteomics/20230720_cremer_all_maincohort/ALL_samples.xlsx")) %>% 
  slice_head(n = nrow(.) - 3) #last line is the information on the #9 being the IRS
```

Mapping the MS sample ID to the column in the proteomics data set is simply chronological.

Then we can see how many of the sample names from the MS match to sample names from the FACS data

```{r}
sample_metadata_ms %>% 
  janitor::clean_names() %>% 
  dplyr::select(ms_name, sample_id, sample_name) -> sample_metadata_ms
f

sample_metadata_ms$sample_name[!sample_metadata_ms$sample_name %in% sample_metadata_facs$BM_Nr]
```

There are 4 samples identified in the MS metadata but not in the FACS data.

update: all samples were corrected, there are no unidentified MS samples

```{r}
sample_metadata_ms %>% 
  filter(!sample_name %in% sample_metadata_facs$BM_Nr) 
```

```{r}
sample_metadata_facs$BM_Nr[!sample_metadata_facs$BM_Nr %in% sample_metadata_ms$sample_name]

sample_metadata_facs %>% 
  filter(!BM_Nr %in% sample_metadata_ms$sample_name) 
```

Vice versa, there are 12 samples identified in the FACS data but not measured in MS.

For now we proceed with the 88 samples that went into MS (although we don't have metadata for 4 of them). However, in total 9 samples are duplicated in the MS for balancing the plexes which means that these are actually technical replicates.

```{r}
sample_metadata_ms$sample_name[duplicated(sample_metadata_ms$sample_name)]
```

```{r}

```

```{r}
sample_metadata_ms %>% 
  distinct(sample_name,.keep_all = T) %>% # remove the technical replicates
  left_join(sample_metadata_facs, by=c("sample_name" = "BM_Nr")) -> sample_metadata
```

```{r}
sample_metadata %>% 
  mutate(across(.cols = c(Subtyp, MolGen, Mat, Medium, Zeitpunkt, RNA_seq), ~ as.factor(.)),
         CD45_dim_blasts = stringr::str_remove(CD45_dim_blasts, "%"),
         CD19_positive_blasts = stringr::str_remove(CD19_positive_blasts, "%"),
         across(.cols = c(CD45_dim_blasts, CD19_positive_blasts), ~ as.numeric(.))) -> sample_metadata

tableone::CreateTableOne(vars = c("Subtyp", "MolGen", "KM_Blasten", "pB_Blasten", "Mat", "Medium", "Blasten", "RNA_Seq", "viability_percentage_of_live_cells", "CD45_dim_blasts", "CD19_positive_blasts"), data = sample_metadata) %>% 
  tableone::kableone()
```

```{r}
ggplot(sample_metadata, aes(x=CD45_dim_blasts)) +
  geom_histogram(col = "black")

ggplot(sample_metadata, aes(x=CD19_positive_blasts)) +
  geom_histogram(col = "black")
```

### Molecular classes

For a limited set of samples we have the molecular classes from RNA-seq provided by Kiel.

```{r}
mol_data <- readxl::read_excel("Data/Metadata/Kiel_RNASeq_molecular_classes_all_mainrun.xlsx") %>% 
  janitor::clean_names()

table(mol_data$`BM-Nr.` %in% sample_metadata$sample_name)
```

```{r}
sample_metadata %>% 
  left_join(dplyr::select(mol_data, lab_id, molekularer_subtyp, bm_nr), by=c("sample_name" = "bm_nr")) -> sample_metadata

```

### Proteomics

parse the data

```{r}
all_cohort <- 
  read_tsv("Data/Proteomics/20230720_cremer_all_maincohort/Cremer_ALL_23-07-14.txt") %>% 
  janitor::clean_names(parsing_option = 3)
```

identify missing gene names

```{r}
all_cohort %>% dplyr::select(uniprot_ids, gene_names, contains("reporter"))

is.na(all_cohort$gene_names) %>% sum()
duplicated(all_cohort$gene_names) %>% sum()
is.na(all_cohort$uniprot_ids) %>% sum()
duplicated(all_cohort$uniprot_ids) %>% sum()

all_cohort[is.na(all_cohort$gene_names), c("gene_names", "uniprot_ids", "protein_names")] %>% 
  mutate(uniprotids_short = stringr::str_extract(uniprot_ids, "^.*?(?=(;|$))")) %>% 
  pull(uniprotids_short) -> missing_uniprots
```

```{r}

UniprotR::GetProteinAnnontate(ProteinAccList = missing_uniprots$uniprotswissprot, 
                              columns = c("accession", "id", "gene_names", "protein_name")) -> missing_uniprots.uniprotr

missing_uniprots.uniprotr %>% 
  mutate(Gene.Names = ifelse(Gene.Names == "NA", Entry, Gene.Names)) %>% 
  dplyr::select(Entry, Gene.Names) %>% 
  deframe() -> lookup_table

all_cohort[is.na(all_cohort$gene_names), c("gene_names", "uniprot_ids", "protein_names")] %>% 
  mutate(uniprotids_short = stringr::str_extract(uniprot_ids, "^.*?(?=(;|$))")) %>% 
  dplyr::select(uniprot_ids, uniprotids_short) %>% 
  mutate(gene.names = lookup_table[uniprotids_short]) %>% 
  dplyr::select(uniprot_ids, gene.names) %>% 
  deframe() -> lookup_table.long

all_cohort %>% 
  mutate(gene_names = ifelse(is.na(gene_names), lookup_table.long[uniprot_ids], gene_names)) -> all_cohort


```

identify "excel hickups" and depricated/suspended HGNC symbols

```{r}

HGNChelper::checkGeneSymbols(all_cohort$gene_names) %>%    mutate(final_symbol = ifelse(is.na(Suggested.Symbol), x, Suggested.Symbol)) %>%  
  pull(final_symbol) -> corrected_genes  

all_cohort$gene_names <- corrected_genes
```

identify duplicated genes

```{r}
all_cohort$gene_names[duplicated(all_cohort$gene_names)] -> duplicated_genes

all_cohort %>% 
  filter(gene_names %in% duplicated_genes) %>%  
  rowwise() %>% 
  mutate(all_nas = sum(is.na(c_across(cols = contains("reporter"))))) %>% 
  relocate(all_nas, .after = gene_names) %>% 
  relocate(peptides, .after = gene_names) %>% 
  group_by(gene_names) %>% 
  arrange(.by_group = T, all_nas, desc(peptides)) %>% 
  slice_head(n = 1) %>% 
  pull(uniprot_ids) -> keep_genes

all_cohort %>% 
  filter(!(gene_names %in% duplicated_genes) | (gene_names %in% duplicated_genes & uniprot_ids %in% keep_genes)) -> all_cohort
```

for the majority of duplicated gene names, one is either missing or very lowly expressed, thus we keep those genes with the 1) lowest number of missing quantifications and 2) highest number of identified peptides

## Proteomics QC

```{r}
tibble(ID = colnames(dplyr::select(all_cohort, contains("reporter")))) %>% 
  mutate(ID = stringr::str_remove(ID, "reporter_intensity_corrected_"),
         plex = stringr::str_extract(ID, "(?<=_)\\d{1,3}"),
         replicate = stringr::str_extract(ID, "r1|r2"),
         ID_wo_rep = paste(stringr::str_extract(ID, "[1-9]"), plex, sep = "_")) -> metaframe
  
```

```{r}

# rename w/o prefix
all_cohort %>% 
  dplyr::rename_with(.cols = contains("reporter"), .fn = ~ stringr::str_remove(., "reporter_intensity_corrected_")) -> all_cohort


all_cohort %>% 
  dplyr::select(gene_names, contains("_r")) %>% 
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "int") %>%
  left_join(metaframe, by=c("sample" = "ID")) %>%  
  ggplot(aes(x=sample, y = int, fill = plex)) + 
  geom_boxplot(outlier.shape = NA, coef = 0) +
  scale_y_log10() +
  theme(axis.text.x = element_blank()) +
  ylim(c(1e3, 5e3)) + 
  labs(title = "non-corrected sample-wise intensities") + 
  scale_x_discrete(limits = arrange(metaframe, plex)$ID) -> non_normalized_sample_wise_intensities

all_cohort %>% 
  dplyr::select(gene_names, contains("_r")) %>% 
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "int") %>%
  left_join(metaframe, by=c("sample" = "ID")) %>% 
  group_by(plex, gene_names) %>% 
  summarize(int = mean(int)) %>% 
  ggplot(aes(x=plex, y = int, fill = plex)) + 
  geom_boxplot(outlier.shape = NA, coef = 0) +
  scale_y_log10() +
  theme(axis.text.x = element_blank()) +
  ylim(c(1e3, 5e3)) + 
  labs(title = "non-corrected plex-wise intensities") -> non_normalized_plex_wise_intensities

all_cohort %>% 
  dplyr::select(gene_names, contains("_r")) %>% 
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "int") %>%
  left_join(metaframe, by=c("sample" = "ID")) %>% 
  group_by(replicate, gene_names) %>% 
  summarize(int = mean(int)) %>% 
  ggplot(aes(x=replicate, y = int, fill = replicate)) + 
  geom_boxplot(outlier.shape = NA, coef = 0) +
  scale_y_log10() +
  theme(axis.text.x = element_blank()) +
  ylim(c(1e3, 5e3)) + 
  labs(title = "non-corrected replicate-wise intensities") -> non_normalized_replicate_wise_intensities

all_cohort %>% 
  dplyr::select(gene_names, contains("_r")) %>% 
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "int") %>%
  left_join(metaframe, by=c("sample" = "ID")) %>% 
  group_by(replicate, plex, gene_names) %>% 
  summarize(int = mean(int)) %>% 
  ggplot(aes(x=replicate, y = int, fill = plex)) + 
  geom_boxplot(outlier.shape = NA, coef = 0) +
  scale_y_log10() +
  theme(axis.text.x = element_blank()) +
  ylim(c(1e3, 5e3)) + 
  labs(title = "non-corrected replicate- and plex-wise intensities") -> non_normalized_replicates_and_plex_wise_intensities

all_cohort %>% 
  dplyr::select(gene_names, contains("9_r")) %>% 
  column_to_rownames("gene_names") %>% 
  as.matrix() %>% 
  cor(use = "pairwise.complete.obs") %>% 
  ggcorrplot::ggcorrplot(lab = T, hc.order = T, show.legend = F, title = "non-corrected inter-plex correlation") -> reference_channel_corrplot

all_cohort %>% 
  dplyr::select(gene_names, contains("_r")) %>% 
  column_to_rownames("gene_names") %>% 
  as.matrix() %>% 
  t() %>% 
  pcaMethods::pca() %>% 
  pcaMethods::scores() %>% 
  as_tibble(rownames = "ID") %>% 
  left_join(metaframe, by=c("ID")) %>% 
  ggplot(aes(x=PC1, y = PC2, col = plex, shape = replicate, label = ID_wo_rep)) + 
  geom_point(size = 2) +
  ggrepel::geom_text_repel() + 
  labs(title = "non-corrected PCA plot") -> non_normalized_pca_plot

cowplot::plot_grid(non_normalized_sample_wise_intensities + theme(legend.position = "none"), 
                   non_normalized_plex_wise_intensities + theme(legend.position = "none"), 
                   non_normalized_replicates_and_plex_wise_intensities + theme(legend.position = "none"),
                   cowplot::get_legend(non_normalized_sample_wise_intensities), ncol = 3, nrow = 2, rel_heights = c(0.9, 0.1)) -> toprowplots

cowplot::plot_grid(non_normalized_replicate_wise_intensities,
                   reference_channel_corrplot,
                   non_normalized_pca_plot, ncol = 3) -> bottomrowplots

cowplot::plot_grid(toprowplots,
                   bottomrowplots, nrow = 2) %>% 
  ggsave(width = 33, height = 15, unit = "cm", dpi = 300, device = "jpg", filename = "non_corrected_qc_plots.jpg", scale = 2.5)


```

plexes 196 and 271 show lower correlation compared to all the others.

confirm that each plex is loaded with the sample number of samples

```{r}
metaframe %>% 
  group_by(plex, replicate) %>% 
  summarize(n())
```

confirm that each sample has 2 replicates

```{r}
metaframe %>% 
  group_by(ID_wo_rep) %>% 
  summarize(n())
```

### Sample-loading correction

```{r}
all_cohort %>% 
  dplyr::select(gene_names, contains("_r")) %>% 
  column_to_rownames("gene_names") %>% 
  as.matrix() -> all_cohort.mat

# calculate the target size
target_size <- mean(matrixStats::colSums2(all_cohort.mat, na.rm =T))

# all_cohort.mat %>% 
#   colSums(na.rm = T) %>% 
#   mean(na.rm = T) -> target_size_factor

# calculate the normalization factors 
target_size/matrixStats::colSums2(all_cohort.mat, na.rm = T) -> normalization_factor

# apply the normalization factors column-wise
assign("all_cohort.mat_corrected", sweep(all_cohort.mat, MARGIN = 2, STATS = normalization_factor, FUN = "*")) 

matrixStats::colSums2(all_cohort.mat_corrected, na.rm = T) 
```

```{r}

all_cohort.mat_corrected %>% 
  as_tibble(rownames = "gene_names") -> all_cohort.slc

all_cohort.slc %>% 
  dplyr::select(gene_names, contains("_r")) %>% 
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "int") %>%
  left_join(metaframe, by=c("sample" = "ID")) %>% 
  ggplot(aes(x=sample, y = int, fill = plex)) + 
  geom_boxplot(outlier.shape = NA, coef = 0) +
  scale_y_log10() +
  theme(axis.text.x = element_blank()) +
  ylim(c(1e3, 5e3)) + 
  labs(title = "sl-corrected sample-wise intensities") +
  scale_x_discrete(limits = arrange(metaframe, plex)$ID) -> slc_sample_wise_intensities

all_cohort.slc %>% 
  dplyr::select(gene_names, contains("_r")) %>% 
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "int") %>%
  left_join(metaframe, by=c("sample" = "ID")) %>% 
  group_by(plex, gene_names) %>% 
  summarize(int = mean(int)) %>% 
  ggplot(aes(x=plex, y = int, fill = plex)) + 
  geom_boxplot(outlier.shape = NA, coef = 0) +
  scale_y_log10() +
  theme(axis.text.x = element_blank()) +
  ylim(c(1e3, 5e3)) + 
  labs(title = "sl-corrected plex-wise intensities") -> slc_plex_wise_intensities

all_cohort.slc %>% 
  dplyr::select(gene_names, contains("_r")) %>% 
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "int") %>%
  left_join(metaframe, by=c("sample" = "ID")) %>% 
  group_by(replicate, gene_names) %>% 
  summarize(int = mean(int)) %>% 
  ggplot(aes(x=replicate, y = int, fill = replicate)) + 
  geom_boxplot(outlier.shape = NA, coef = 0) +
  scale_y_log10() +
  theme(axis.text.x = element_blank()) +
  ylim(c(1e3, 5e3)) + 
  labs(title = "sl-corrected replicate-wise intensities") -> slc_replicate_wise_intensities

all_cohort.slc %>% 
  dplyr::select(gene_names, contains("_r")) %>% 
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "int") %>%
  left_join(metaframe, by=c("sample" = "ID")) %>% 
  group_by(replicate, plex, gene_names) %>% 
  summarize(int = mean(int)) %>% 
  ggplot(aes(x=replicate, y = int, fill = plex)) + 
  geom_boxplot(outlier.shape = NA, coef = 0) +
  scale_y_log10() +
  theme(axis.text.x = element_blank()) +
  ylim(c(1e3, 5e3)) + 
  labs(title = "sl-corrected replicate- and plex-wise intensities") -> slc_replicates_and_plex_wise_intensities

all_cohort.slc %>% 
  dplyr::select(gene_names, contains("9_r")) %>% 
  column_to_rownames("gene_names") %>% 
  as.matrix() %>% 
  cor(use = "pairwise.complete.obs") %>% 
  ggcorrplot::ggcorrplot(lab = T, hc.order = T, show.legend = F, title = "sl-corrected inter-plex correlation") -> slc_reference_channel_corrplot

all_cohort.slc %>% 
  dplyr::select(gene_names, contains("_r")) %>% 
  column_to_rownames("gene_names") %>% 
  as.matrix() %>% 
  t() %>% 
  pcaMethods::pca() %>% 
  pcaMethods::scores() %>% 
  as_tibble(rownames = "ID") %>% 
  left_join(metaframe, by=c("ID")) %>% 
  ggplot(aes(x=PC1, y = PC2, col = plex, shape = replicate, label = ID_wo_rep)) + 
  geom_point(size = 2) +
  ggrepel::geom_text_repel() + 
  labs(title = "sl-corrected PCA plot") -> slc_normalized_pca_plot

cowplot::plot_grid(slc_sample_wise_intensities + theme(legend.position = "none"), 
                   slc_plex_wise_intensities + theme(legend.position = "none"), 
                   slc_replicates_and_plex_wise_intensities + theme(legend.position = "none"),
                   cowplot::get_legend(slc_replicates_and_plex_wise_intensities), ncol = 3, nrow = 2, rel_heights = c(0.9, 0.1)) -> toprowplots

cowplot::plot_grid(slc_replicate_wise_intensities,
                   slc_reference_channel_corrplot,
                   slc_normalized_pca_plot, ncol = 3) -> bottomrowplots

cowplot::plot_grid(toprowplots,
                   bottomrowplots, nrow = 2) %>% 
  ggsave(width = 33, height = 15, unit = "cm", dpi = 300, device = "jpg", filename = "slc_corrected_qc_plots.jpg", scale = 2.5)
```

### Internal reference standard (IRS) normalization

```{r}
all_cohort.slc %>% 
  #head() %>% 
  dplyr::select(contains("9_")) %>%
  as.matrix() %>%  
  log() %>% 
  matrixStats::rowMeans2(na.rm = T) %>% 
  exp() -> irs_target_intensities

irs_target_intensities/all_cohort.slc[, grepl(pattern = "9_", x = colnames(all_cohort.slc))] %>%
  setNames(stringr::str_remove(string = colnames(.), pattern = "9_")) -> irs_correction_matrix

all_cohort.slc %>%
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "intensities") %>%
  mutate(plex = stringr::str_extract(string = sample, pattern = "r[1,2]_\\d{3}")) %>%
  nest_by(plex) %>%
  {
    split(.$data, .$plex)
  } %>%
  purrr::imap_dfc(~ pivot_wider(.x[[1]], id_cols = gene_names, names_from = sample, values_from = intensities) %>%
               column_to_rownames("gene_names") %>%
                apply(MARGIN = 2,
                  FUN = function(n) irs_correction_matrix[, grepl(x = colnames(irs_correction_matrix),pattern =  .y[[1]])]*n) %>% bind_cols()) -> all_cohort.slc.irs

# mean-aggregate the technical replicates
all_cohort.slc.irs %>% 
  select(-contains("9_")) %>% 
  log2() %>% 
  bind_cols(gene_names = rownames(all_cohort.mat)) %>% 
  relocate(gene_names, .before = `1_r1_193`) %>% 
  pivot_longer(cols = -gene_names, names_to = "ID", values_to = "int") %>% 
  left_join(metaframe, by=c("ID")) %>% 
  group_by(gene_names, plex, ID_wo_rep) %>% 
  summarize(int = mean(int, na.rm = T)) %>% 
  pivot_wider(id_cols = gene_names, names_from = ID_wo_rep, values_from = int) %>% 
  ungroup() %>% 
  mutate(across(.cols = -gene_names, ~ ifelse(is.nan(.), NA_integer_, .))) -> all_cohort.fin

# remove proteins that are missing in more than 50% of the samples
all_cohort.fin %>% 
  rowwise() %>% 
  mutate(n_missing = sum(
    is.na(c_across(`1_193`:last_col()))
  )) %>% 
  relocate(n_missing, .before = `1_193`) %>% 
  filter(n_missing <= 0.5 * 88) %>% 
  dpylr::select(-n_missing) %>% 
  ungroup() -> all_cohort.fin
 
```

### QC plots post SLC and IRS

```{r}
all_cohort.fin %>% 
  #dplyr::select(gene_names, contains("_r")) %>% 
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "int") %>%
  mutate(plex = stringr::str_extract(sample, "(?<=_)\\d{1,3}")) %>% 
  ggplot(aes(x=fct_reorder(sample, plex), y = int, fill = plex)) + 
  geom_boxplot(outlier.shape = NA, coef = 0) +
  #scale_y_log10() +
  theme(axis.text.x = element_blank()) +
  #ylim(c(1e3, 5e3)) + 
  labs(title = "irs-corrected sample-wise intensities")  -> irs_sample_wise_intensities

all_cohort.fin %>% 
  #dplyr::select(gene_names, contains("_r")) %>% 
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "int") %>%
  mutate(plex = stringr::str_extract(sample, "(?<=_)\\d{1,3}")) %>% 
  group_by(plex, gene_names) %>% 
  summarize(int = mean(int)) %>% 
  ggplot(aes(x=plex, y = int, fill = plex)) + 
  geom_boxplot(outlier.shape = NA, coef = 0) +
  #scale_y_log10() +
  theme(axis.text.x = element_blank()) +
  #ylim(c(1e3, 5e3)) + 
  labs(title = "irs-corrected plex-wise intensities") -> irs_plex_wise_intensities


all_cohort.fin %>% 
  #dplyr::select(gene_names, contains("_r")) %>% 
  column_to_rownames("gene_names") %>% 
  as.matrix() %>% 
  t() %>% 
  pcaMethods::pca() %>% 
  pcaMethods::scores() %>% 
  as_tibble(rownames = "ID") %>% 
  mutate(plex = stringr::str_extract(ID, "(?<=_)\\d{1,3}")) %>% 
  ggplot(aes(x=PC1, y = PC2, col = plex, label = ID)) + 
  geom_point(size = 2) +
  ggrepel::geom_text_repel() + 
  labs(title = "irs-corrected PCA plot") -> irs_normalized_pca_plot


cowplot::plot_grid(irs_sample_wise_intensities, 
                   irs_plex_wise_intensities,
                   irs_normalized_pca_plot) %>% 
  ggsave(width = 33, height = 15, unit = "cm", dpi = 300, device = "jpg", filename = "irs_corrected_qc_plots.jpg", scale = 2.5)
```

There is still a substantial impact of plex on intensities thus we further use harmonizR with plex as batch vector.

```{r}

tibble(ID = colnames(all_cohort.fin.mat)) %>%
  rowid_to_column(var = "sample") %>% 
  mutate(batch = stringr::str_extract(ID, "(?<=_)\\d{1,3}")) %>% 
  relocate(sample, .after = ID) -> batch_df

all_cohort.fin %>% 
  column_to_rownames("gene_names") %>% 
  as.data.frame() -> all_cohort.fin.df

HarmonizR::harmonizR(data_as_input = all_cohort.fin.df, description_as_input = as.data.frame(batch_df), plot = "samplemeans") -> all_cohort.fin.harmonizR

all_cohort.fin.harmonizR %>% 
  as_tibble(rownames = "gene_names") -> all_cohort.harmonizR

all_cohort.harmonizR %>% 
  #dplyr::select(gene_names, contains("_r")) %>% 
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "int") %>%
  mutate(plex = stringr::str_extract(sample, "(?<=_)\\d{1,3}")) %>% 
  ggplot(aes(x=fct_reorder(sample, plex), y = int, fill = plex)) + 
  geom_boxplot(outlier.shape = NA, coef = 0) +
  #scale_y_log10() +
  theme(axis.text.x = element_blank()) +
  #ylim(c(1e3, 5e3)) + 
  labs(title = "irs-normalized an harmonizR-corrected sample-wise intensities")  -> irs_harmonizr_sample_wise_intensities

all_cohort.harmonizR %>% 
  #dplyr::select(gene_names, contains("_r")) %>% 
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "int") %>%
  mutate(plex = stringr::str_extract(sample, "(?<=_)\\d{1,3}")) %>% 
  group_by(plex, gene_names) %>% 
  summarize(int = mean(int)) %>% 
  ggplot(aes(x=plex, y = int, fill = plex)) + 
  geom_boxplot(outlier.shape = NA, coef = 0) +
  #scale_y_log10() +
  theme(axis.text.x = element_blank()) +
  #ylim(c(1e3, 5e3)) + 
  labs(title = "irs-normalized an harmonizR-corrected plex-wise intensities") -> irs_harmonizr_plex_wise_intensities


all_cohort.harmonizR %>% 
  #dplyr::select(gene_names, contains("_r")) %>% 
  column_to_rownames("gene_names") %>% 
  as.matrix() %>% 
  t() %>% 
  pcaMethods::pca() %>% 
  pcaMethods::scores() %>% 
  as_tibble(rownames = "ID") %>% 
  mutate(plex = stringr::str_extract(ID, "(?<=_)\\d{1,3}")) %>% 
  ggplot(aes(x=PC1, y = PC2, col = plex, label = ID)) + 
  geom_point(size = 2) +
  ggrepel::geom_text_repel() + 
  labs(title = "irs-normalized an harmonizR-corrected PCA plot") -> irs_harmonizr_normalized_pca_plot


cowplot::plot_grid(irs_harmonizr_sample_wise_intensities, 
                   irs_harmonizr_plex_wise_intensities,
                   irs_harmonizr_normalized_pca_plot) %>% 
  ggsave(width = 33, height = 15, unit = "cm", dpi = 300, device = "jpg", filename = "irs_harzmonizr_corrected_qc_plots.jpg", scale = 2.5)
```

Missing proteins per plex

```{r}
as_tibble(matrixStats::colSums2(is.na(all_cohort.harmonizR)), rownames = "sample") %>% 
  filter(sample != "gene_names") %>% 
  mutate(plex = stringr::str_extract(sample, "(?<=_)\\d{1,3}"),
         value = value/nrow(all_cohort.fin.harmonizR) * 100) %>% 
  distinct(plex, value) %>% 
  ggplot(aes(x=fct_reorder(plex, value), y = value)) +
  geom_col(position = "identity") +
  labs(x="plex", y = "[%] of proteins missing")
```

Statistical correlation between plex and PCs to compare pre- and post-harmonizR-workflow

```{r}
all_cohort.fin.mat %>% 
  t() %>% 
  pcaMethods::pca(nPcs = 10) %>% 
  pcaMethods::scores() %>% 
  as_tibble(rownames = "sample") %>% 
  mutate(plex = stringr::str_extract(sample, "(?<=_)\\d{1,3}")) %>% 
  pivot_longer(cols = c(-sample, -plex), names_to = "PC", values_to = "score") %>% 
  group_by(PC) %>% 
  rstatix::anova_test(plex ~ score) %>% 
  rstatix::adjust_pvalue() -> anova_pre_harmonizr

all_cohort.harmonizR %>% 
  column_to_rownames("gene_names") %>% 
  as.matrix() %>% 
  t() %>% 
  pcaMethods::pca(nPcs = 10) %>% 
  pcaMethods::scores() %>% 
  as_tibble(rownames = "sample") %>% 
  mutate(plex = stringr::str_extract(sample, "(?<=_)\\d{1,3}")) %>% 
  pivot_longer(cols = c(-sample, -plex), names_to = "PC", values_to = "score") %>% 
  group_by(PC) %>% 
  rstatix::anova_test(plex ~ score) %>% 
  rstatix::adjust_pvalue() -> anova_post_harmonizr
```

```{r}
all_cohort.fin.mat %>% 
  t() %>% 
  pcaMethods::pca(nPcs = 10) %>% 
  pcaMethods::scores() %>% 
  as_tibble(rownames = "sample") %>% 
  mutate(plex = stringr::str_extract(sample, "(?<=_)\\d{1,3}")) %>% 
  dplyr::select(sample, plex, PC1, PC3, PC7, PC8) %>% 
  pivot_longer(cols = c(PC3, PC7, PC8), names_to = "PC", values_to = "score") %>% 
  ggplot(aes(x=PC1, y = score, col = plex)) + 
  geom_point(size = 2) +
  facet_wrap(. ~ PC) +
  labs(titel = "significantly correlated PCs pre harominzR") -> pcs_pre_harmonizR

all_cohort.harmonizR %>%
  column_to_rownames("gene_names") %>% 
  as.matrix() %>% 
  t() %>% 
  pcaMethods::pca(nPcs = 10) %>% 
  pcaMethods::scores() %>% 
  as_tibble(rownames = "sample") %>% 
  mutate(plex = stringr::str_extract(sample, "(?<=_)\\d{1,3}")) %>% 
  dplyr::select(sample, plex, PC1, PC3, PC7, PC8) %>% 
  pivot_longer(cols = c(PC3, PC7, PC8), names_to = "PC", values_to = "score") %>% 
  ggplot(aes(x=PC1, y = score, col = plex)) + 
  geom_point(size = 2) +
  facet_wrap(. ~ PC) +
  labs(titel = "significantly correlated PCs post harominzR") -> pcs_post_harmonizR

cowplot::plot_grid(pcs_pre_harmonizR + theme(legend.position = "none"), pcs_post_harmonizR + theme(legend.position = "none"), cowplot::get_legend(pcs_post_harmonizR), ncol = 1, nrow = 3, rel_heights = c(0.5, 0.5, 0.1))
```

Lastly, we aggregate the technical replicates which where introduced by replicating a set of samples for plex balancing. For this, we first confirm that the are in fact correctly labeled as replicates

```{r}
c(3585L, 3585L, 3432L, 3432L, 1866L, 1866L, 1589L, 1589L) %>% 
c(1043L, 1043L, 1043L, 1035L, 1035L, 1035L, 1007L, 1007L) -> replicate_samples

sample_metadata_ms %>% 
  filter(sample_name %in% replicate_samples) %>% 
  pull(ms_name) -> replicate_samples

all_cohort.fin.harmonizR[, replicate_samples] %>% 
  cor(use = "pairwise.complete.obs") %>% 
  ComplexHeatmap::Heatmap()

```

This is very suspicious because for many of the samples that were labelled as replicates actually the measurements are very different.

We can build a large scale correlation matrix and try to identify which samples actually seem to be replicates.

```{r}
all_cohort.fin.harmonizR %>% 
  cor(use = "pairwise.complete.obs") %>% 
  ComplexHeatmap::Heatmap()
```

Based on the visualization we identify replicates as follows

```{r}
all_cohort.fin.harmonizR %>%
  rownames_to_column("gene_names") %>%
  pivot_longer(cols = -gene_names, names_to = "sample", values_to = "int") %>%
  left_join(sample_metadata_ms, by=c("sample" = "ms_name")) %>%
  group_by(sample_name, gene_names, sample_id) %>%
  summarize(int = mean(int, na.rm = T)) %>%
  ungroup() %>%
  pivot_wider(id_cols = gene_names, names_from = sample_id, values_from = int) %>%
  mutate(across(.cols = -gene_names, ~ ifelse(is.nan(.), NA_integer_, .))) -> all_cohort.fin.harmonizR.aggr
```

To sum up, the pre-processing steps for the data set were

-   sample loading correction

-   internal reference standard normalization

-   log2 normalization

-   batch correction with harmonizR (ComBat parametric core)

-   aggregation of plex-balancing replicates

```{r}
prot_all <- all_cohort.fin.harmonizR.aggr
```

!!!!!! to do - create a final summarized experiment object for export !!!!!

## Data exploration

Correlation of proteomics with sample metadata

```{r}
prot_all %>% 
  column_to_rownames("gene_names") %>% 
  as.matrix() %>% 
  t() %>% 
  pcaMethods::pca(nPcs = 10) %>% 
  pcaMethods::scores() %>% 
  as_tibble(rownames = "sample") %>% 
  left_join(sample_metadata, by=c("sample" = "sample_id")) %>% 
  dplyr::select(sample, PC1:PC10, viability_percentage_of_life_cels, CD45_dim_blasts, CD19_positive_blasts) %>% 
  pivot_longer(cols = c(PC1:PC10), names_to = "PC", values_to = "score") %>% 
  pivot_longer(cols = c(viability_percentage_of_life_cels:CD19_positive_blasts), names_to = "variable", values_to = "value") %>% 
  nest_by(variable) %>% 
  {
    imap(.$data, ~ group_by(.x, PC) %>% 
          rstatix::cor_test(value,score) %>% 
           rstatix::adjust_pvalue())
  }
  
```

```{r}
prot_all %>% 
  column_to_rownames("gene_names") %>% 
  as.matrix() %>% 
  t() %>% 
  pcaMethods::pca(nPcs = 10) %>% 
  pcaMethods::scores() %>% 
  as_tibble(rownames = "sample") %>% 
  left_join(sample_metadata, by=c("sample" = "sample_id")) %>% 
  dplyr::select(sample, PC1:PC10, viability_percentage_of_life_cels, CD45_dim_blasts, CD19_positive_blasts) %>% 
  pivot_longer(cols = c(PC1:PC10), names_to = "PC", values_to = "score") %>% 
  pivot_longer(cols = c(viability_percentage_of_life_cels:CD19_positive_blasts), names_to = "variable", values_to = "value") %>% 
  ggplot(aes(x=score, y = value)) +
  geom_point() +
  stat_smooth(method = "lm") +
  ggpubr::stat_cor() +
  facet_wrap(PC ~ variable, scale = "free")
```

It seems that sample quality is good and there are no lower quality samples that significantly impact the proteomic data set.

```{r}
sample_metadata %>% 
  dplyr::select(Subtyp, Mat, Medium, viability_percentage_of_life_cels, CD45_dim_blasts, CD19_positive_blasts, molekularer_subtyp) %>% 
  as.data.frame() %>% 
  {
    ComplexHeatmap::HeatmapAnnotation(df = .)
  } -> topann

prot_all %>% 
  column_to_rownames("gene_names") %>% 
  as.matrix() %>% 
  t() %>% 
  vegan::vegdist(method = "euclidean", na.rm = T) -> prot_all.dist

prot_all.dist %>% 
  as.matrix() %>% 
  ComplexHeatmap::Heatmap(top_annotation = topann)
```

```{r}
prot_all %>% 
  column_to_rownames("gene_names") %>% 
  as.matrix() %>% 
  t() %>% 
  pcaMethods::pca() %>% 
  pcaMethods::scores() %>% 
  as_tibble(rownames = "sample_id") %>% 
  left_join(sample_metadata, by="sample_id") %>% 
  ggplot(aes(x=PC1, y = PC2, col = molekularer_subtyp)) +
  geom_point(size = 2) 
```

### Consensus Clustering

```{r}
library(ConsensusClusterPlus)
prot_all.mat <- as.matrix(column_to_rownames(prot_all, "gene_names")) 

# DreamAI impute on cluster
prot_all.mat.imp <- readRDS("prot_all.mat.imp.RDS")
prot_all.mat.imp <- prot_all.mat.imp$Ensemble
```

```{r}
library(umap)
umap(t(prot_all.mat.imp)) -> umap.out

umap.out$layout %>% 
  as_tibble(rownames = "sample_id") %>% 
  left_join(sample_metadata, by="sample_id") %>% 
  ggplot(aes(x=molekularer_subtyp, y = V2)) +
  geom_violin() +
  ggpubr::stat_compare_means()
```

### BayesNMF

```{r}
ccfindR::scNMFSet(prot_all.mat) -> prot_all.mat.scNMFSet
set.seed(069)
ccfindR::vb_factorize(object = prot_all.mat.scNMFSet, ranks = 2:6, nrun = 10, progress.bar = T)
```

### NMF clustering

```{r}
library(NMF)

doParallel::registerDoParallel(cores = parallel::detectCores() - 1)
# done on the cluster
# the CPTAC single omics NMF clustering workflow as described here https://github.com/broadinstitute/PANOPLY/wiki/Data-Analysis-Modules%3A-panoply_so_nmf includes a row-wise z-scoring prior to clustering and the algorithm being used is "lee"
# since z-scoring introduces negative values, we apply the transformation suggested by CPTAG
# create a positive and negative values-only matrix with the signs removed and negative/positive values zeroed out
# after NMF, recombine the final matrix with the sign matrix of the initial z-score matrix


prot_all.mat.z_scored <- t(scale(t(prot_all.mat.imp)))
make.non.negative(prot_all.mat.z_scored) -> prot_all.mat.z_scord_combined

# run on cluster
# nmf(x = prot_all.mat.z_scord_combined, rank = 2:10, method = "brunet", seed = 069, nrun = 200, .options ="pv", .pbackend = "par") -> nmf.out

nmf.out <- readRDS("nmf.out.RDS")

rank.coph <- sapply(nmf.out$consensus, NMF::cophcor)
rank.disp <- sapply(nmf.out$consensus, NMF::dispersion)
rank.coph.disp <- rank.disp^(1-rank.coph)

GetBestRank(rank.coph.disp)

# estimate best rank as 4 which is in line with the visual metrics
# extract best rank 4

res.rank <- nmf.out$fit[["4"]]

# get cluster assignments
clus.assignments <- predict(res.rank)


```

```{r}
ComplexHeatmap::Heatmap(prot_all.mat.z_scored, column_split = clus.assignments)
```

We can now re-compute the feature matrix

```{r}
# meta feature matrix 
W <- res.rank@fit@W

colnames(W) <- 1:ncol(W)

## row-normalize
W.norm <- t(apply(W, 1,  function(x)x/sum(x)))

## combine up/down: take highest normalized score
feat.comb <- unique( sub('^(.*)_(up|down)$' , '\\1', rownames(W.norm)) )

W.norm.dir <- W.norm
direction.tmp <- sub('.*_(.*)$', '\\1', rownames(W.norm.dir))

## sign the coefficients
direction.tmp[direction.tmp == 'down' ] <- -1
direction.tmp[direction.tmp == 'up' ] <- 1
direction.tmp <- as.numeric(direction.tmp)
W.norm.dir <- direction.tmp*W.norm.dir


```

```{r}
library(parallel)
library(doParallel)

#cores <- detectCores() - 1
# cl <- makeCluster(cores)
# registerDoParallel(cl)
feat.comb <- stringr::str_remove_all(feat.comb, "_(up|down)")
W.tmp2 <- foreach(i = 1:length(feat.comb)) %dopar% {
  library(glue)
  library(stringr)
  ii=feat.comb[i]
  idx.tmp <- grep(glue("^{ii}_(up|down)$"), rownames(W.norm))
  W.tmp <- W.norm.dir[ idx.tmp, ]
   ## if multiple rows were found, choose max of abs-val
    if(length(idx.tmp) > 1){
      W.tmp <- apply(W.tmp, 2, function(x) x[ which.max(abs(x)) ])
    }
  
    W.tmp
  }

#on.exit(stopCluster(cl))

W.norm.comb <- Reduce(rbind, W.tmp2)
dimnames(W.norm.comb) <- list(feat.comb, colnames(W))
#W.norm.comb <- W.norm.comb[seq(1, nrow(W.norm.comb), 2),]

protein_clustering <- apply(W.norm.comb, 1, which.max)


```

```{r}

heatmap_topann <- 
ComplexHeatmap::HeatmapAnnotation(df = data.frame(subtyp = sample_metadata$Subtyp, mol_subtyp = sample_metadata$molekularer_subtyp), col = list(subtyp = c("prÃ¤-B/c" = "#ADD8E6", "pro-B" = "#8B0000"),
                                                                                                                                                mol_subtyp = c("BCR::ABL1-like" = "#E57373", "TCF3::PBX1" = "#FFA726", "ZNF384" = "#FFF176", "DUX4" = "#81C784", "KMT2A" = "#64B5F6", "PAX5alt" = "#BA68C8", "PAX5 P80R" = "#FF8A80", "unassigned" = "#4DB6AC", "MEF2D" = "#A1887F")))

col_range <- circlize::colorRamp2(breaks = c(-2,0,2),colors = c("#1d3557", "#a8dadc", "#e63946"))

ComplexHeatmap::Heatmap(prot_all.mat.z_scored, row_split = protein_clustering, column_split = predict(res.rank), show_column_names = F, show_row_names = F, top_annotation = heatmap_topann, show_column_dend = T, show_row_dend = F, col = col_range) -> heatmap.out


```

```{r}
pdf(file = "all_proteomics_heatmap2.pdf")
heatmap.out
dev.off()
```

And plot the samples in the NMF reduced space

```{r}
res.rank@fit@H %>% 
  t() %>% 
  umap::umap() -> umap.out

umap.out$layout %>% 
  as_tibble(rownames ="id") %>% 
  bind_cols(classes = clus.assignments) %>% 
  ggplot(aes(x=V1, y = V2, col = classes)) +
  geom_point(size = 2)
```

```{r}
# extract DE proteins using a one-vs-rest 2-sample moderated t-statistic 
library(limma)

mod.t <- function(m, group) {
  group_vec <- as.numeric(clus.assignments == group)
  mm <- model.matrix(~ 0 + factor(group_vec))
  colnames(mm) <- c("rest", "one")
  cm <- makeContrasts(one - rest, levels = mm)
  lmFit(m, mm) %>% 
    contrasts.fit(cm) %>% 
    eBayes() %>% 
    topTable(number = Inf, sort.by = "logFC")
}

sapply(as.character(1:4), mod.t, m = prot_all.mat, simplify = F) -> modt.out
```

```{r}
library(clusterProfiler)

enrich_clusters <- function(x) {
  # rank by signed logFC * -log10(adj.p.val)
  as_tibble(x, rownames = "gene") %>% 
    mutate(order = logFC * -log10(adj.P.Val)) %>% 
    dplyr::select(gene, order) %>% 
    deframe() %>% 
    sort(decreasing = T) %>% 
    {
      clusterProfiler::gseGO(geneList=., ont = "ALL", OrgDb = "org.Hs.eg.db", keyType = "SYMBOL",minGSSize = 10, maxGSSize = 500)
    }
}

sapply(modt.out, enrich_clusters, simplify = F) -> gsea.out
```

```{r}
# we use compare cluster with the universal GSEA function and the msigdb C5 as the gene set source
msigdbr_c5 <- msigdbr::msigdbr(category = "C5")

sapply(modt.out, function(x){
  as_tibble(x, rownames = "gene") %>% 
    mutate(order = logFC * -log10(adj.P.Val)) %>% 
    dplyr::select(gene, order) %>% 
    deframe() %>% 
    sort(decreasing = T) }, simplify = F) %>% 
  {
    clusterProfiler::compareCluster(geneClusters = ., fun = "GSEA", TERM2GENE = dplyr::select(msigdbr_c5, gs_name, gene_symbol))
  } -> comparecluster.gsea.out

comparecluster.gsea.out %>% 
  filter(NES >0) %>% 
  mutate(GO = factor(stringr::str_extract(ID, "GOBP|GOCC|GOMF|HP"))) %>% 
  dotplot()
```

NMF features vs DE features

```{r}
as_tibble(modt.out[[3]], rownames = "gene") %>% 
    mutate(order = logFC * -log10(adj.P.Val)) %>% 
    dplyr::select(gene, order, logFC, adj.P.Val) %>% 
  left_join(as_tibble(W.norm.comb[,3], rownames = "gene"), by="gene") %>% 
  ggplot(aes(x=order, y = value)) +
  geom_point() +
  cowplot::theme_cowplot()

as_tibble(modt.out[[3]], rownames = "gene") %>% 
    mutate(order = logFC * -log10(adj.P.Val)) %>% 
    dplyr::select(gene, order, logFC, adj.P.Val) %>% 
  left_join(as_tibble(W.norm.comb[,3], rownames = "gene"), by="gene") %>% 
  ggplot(aes(x=logFC, y = value)) +
  geom_point() +
  cowplot::theme_cowplot()

as_tibble(modt.out[[3]], rownames = "gene") %>% 
    mutate(order = logFC * -log10(adj.P.Val)) %>% 
    dplyr::select(gene, order, logFC, adj.P.Val) %>% 
  left_join(as_tibble(W.norm.comb[,3], rownames = "gene"), by="gene") %>% 
  ggplot(aes(x=-log10(adj.P.Val), y = value)) +
  geom_point() +
  cowplot::theme_cowplot()
```

```{r}
# helper function from https://github.com/broadinstitute/PANOPLY/blob/dev/src/panoply_mo_nmf/mo-nmf.r

make.non.negative <- function(m){

  ## up
  m.up <-  t( apply(m, 1, function(x){
    up=rep(0, length(x))
    up[which(x > 0)] <- x[which(x>0)]
    up
  }))
  colnames(m.up) <- colnames(m)
  rownames(m.up) <- paste(rownames(m), 'up', sep='_')
  ## down
  m.down <-  t( apply(m, 1, function(x){
    down=rep(0, length(x))
    down[which(x < 0)] <- abs(x[which(x<0)])
    down
  }))
  colnames(m.down) <- colnames(m)
  rownames(m.down) <- paste(rownames(m), 'down', sep='_')

  ## combine
  m.comb <- rbind(m.up, m.down)
  m.comb <- m.comb[order(rownames(m.comb)),]

  
  ## remove rows only containing zero values
  keep.idx <- which(apply(m.comb, 1, function(x) sum(x != 0) ) > 0)
  m.comb <- m.comb[keep.idx, ]

  return(m.comb)
}
```

```{r}
# helper function from https://github.com/broadinstitute/PANOPLY/blob/dev/src/panoply_mo_nmf/mo-nmf.r

GetBestRank <- function(metric,       ## vector of a metric to assess clustering
                        topn.rank=1,  ## Number of of top N ranks to return
                        exclude_2=F,  ## should rank=2 be excluded?
                        rel.inc=1e-6  ## stop criteria for relative increase from K to K+1
                                      ## update to 1e-6 when applied to: rank.disp^(1-rank.coph)
                        ){

  ## https://stackoverflow.com/questions/6836409/finding-local-maxima-and-minima
  # ## Answer #37
  # localMaxima <- function(x) {
  #   # Use -Inf instead if x is numeric (non-integer)
  #   y <- diff(c(-.Machine$integer.max, x)) > 0L
  #   rle(y)$lengths
  #   y <- cumsum(rle(y)$lengths)
  #   y <- y[seq.int(1L, length(y), 2L)]
  #   if (x[[1]] == x[[2]]) {
  #     y <- y[-1]
  #   }
  #   y
  # }
  #

  if(exclude_2){
     if('2' %in% names(metric))
       metric <- metric[-which(names(metric) == '2')]
  }

  rank.top <- names(metric)[1]

  success <- F
  i <- 1
  while(!success){

    top_k <- metric[rank.top]
    this_k <- metric[i]

    ## last entry
    if(i == length(metric)){
      if(this_k > top_k){
        
        inc_perc <- (this_k - top_k)/abs(top_k)
        if(inc_perc > rel.inc)
          rank.top <- names(metric)[i]
        }
      success <- T
    } else {

      next_k <- metric[i+1]

      if(next_k < this_k){
          i <- i+1
        }
      if(next_k >= this_k){

        if(next_k > top_k){
          
          ## percent increase 
          inc_perc <- (next_k - top_k)/abs(top_k)

          if(inc_perc < rel.inc){
            success <- T
          } else {
            rank.top <- names(metric)[i + 1]
            i <- i + 1

            }
        } else {
          i <- i + 1
        }
      }
    }
  }

  return(rank.top)
}
```

# Summary

# Session Info

last rendered `r sys.Date()`

```{r}
sessionInfo()
```
